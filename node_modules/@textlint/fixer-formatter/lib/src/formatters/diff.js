"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const diff_1 = require("diff");
const chalk_1 = __importDefault(require("chalk"));
const strip_ansi_1 = __importDefault(require("strip-ansi"));
const isFile = (filePath) => {
    try {
        const stats = fs_1.default.statSync(filePath);
        return stats.isFile();
    }
    catch (error) {
        return false;
    }
};
/**
 * Given a word and a count, append an s if count is not one.
 * @param {string} word A word in its singular form.
 * @param {number} count A number controlling whether word should be pluralized.
 * @returns {string} The original word with an s on the end if count is not one.
 */
function pluralize(word, count) {
    return count === 1 ? word : `${word}s`;
}
function isModified(part) {
    if (!part) {
        return false;
    }
    return typeof part === "object" && (part.removed || part.added);
}
function addMarkEachLine(mark, text) {
    if (text.length === 0) {
        return "\n";
    }
    const lines = text.split("\n");
    const markedLines = lines
        .filter((line) => line.length > 0)
        .map((line) => {
        return mark + line;
    });
    return `${markedLines.join("\n")}\n`;
}
function default_1(results, options) {
    // default: true
    const useColor = options.color !== undefined ? options.color : true;
    let output = "\n";
    let totalFixed = 0;
    let errors = 0;
    const summaryColor = "yellow";
    const greenColor = "green";
    results.forEach(function (result) {
        const filePath = result.filePath;
        const messages = result.applyingMessages;
        // still error count
        const remainingMessages = result.remainingMessages;
        errors += remainingMessages.length;
        totalFixed += messages.length;
        if (messages.length === 0) {
            return;
        }
        if (!isFile(filePath)) {
            return;
        }
        output += `${chalk_1.default.underline(result.filePath)}\n`;
        const originalContent = fs_1.default.readFileSync(filePath, "utf-8");
        const diff = (0, diff_1.diffLines)(originalContent, result.output);
        diff.forEach(function (part, index) {
            const prevLine = diff[index - 1];
            const nextLine = diff[index + 1];
            if (!isModified(part) && part.count > 1) {
                const greyColor = "grey";
                /*
                    <MODIFIED>
                    first line
                    ....
                 */
                if (isModified(prevLine)) {
                    const lines = part.value.split("\n");
                    output += `${chalk_1.default[greyColor](lines[0])}\n`;
                }
                output += chalk_1.default[greyColor]("...");
                if (isModified(nextLine)) {
                    const lines = part.value.split("\n");
                    output += `${chalk_1.default[greyColor](lines[lines.length - 1])}\n`;
                }
                /*
                    ...
                    last line
                    <MODIFIED>
                 */
                return;
            }
            // green for additions, red for deletions
            // grey for common parts
            let lineColor;
            let diffMark = "";
            if (part.added) {
                lineColor = "green";
                diffMark = "+ ";
            }
            else if (part.removed) {
                lineColor = "red";
                diffMark = "- ";
            }
            else {
                lineColor = "grey";
                diffMark = "";
            }
            output += chalk_1.default[lineColor](addMarkEachLine(diffMark, part.value));
        });
        output += "\n\n";
    });
    if (totalFixed > 0) {
        output += chalk_1.default[greenColor].bold([
            // http://www.fileformat.info/info/unicode/char/2714/index.htm
            "✔ Fixed ",
            totalFixed,
            pluralize(" problem", totalFixed),
            "\n"
        ].join(""));
    }
    if (errors > 0) {
        output += chalk_1.default[summaryColor].bold([
            // http://www.fileformat.info/info/unicode/char/2716/index.htm
            "✖ Remaining ",
            errors,
            pluralize(" problem", errors),
            "\n"
        ].join(""));
    }
    const finalOutput = totalFixed > 0 ? output : "";
    if (!useColor) {
        return (0, strip_ansi_1.default)(finalOutput);
    }
    return finalOutput;
}
exports.default = default_1;
//# sourceMappingURL=diff.js.map