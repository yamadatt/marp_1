// LICENSE : MIT
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _regexpStringMatcher = require("@textlint/regexp-string-matcher");

var _kuromojin = require("kuromojin");

var DefaultOptions = {
  // オノマトペを許可する
  // 制限: オノマトペを判定する方法がないため、同じカタカナの語が連続したものをオノマトペとして扱う
  // 例) カクカク、ドキドキ、ビリビリ
  // https://ja.wikipedia.org/wiki/%E6%93%AC%E5%A3%B0%E8%AA%9E
  allowOnomatopee: true,
  // 許可する単語
  // RegExp-like Stringを使用可能
  allow: []
};

function isOnomatopee(str) {
  return /^[ァ-ロワヲンー]*$/.test(str);
}
/**
 * 漢数字かどうかを判定する
 * https://azu.github.io/morpheme-match/?text=%E5%80%A4%E3%81%AF%E4%B9%9D%E4%B9%9D%E3%81%A7%E3%81%99%E3%80%82
 * @param {import("kuromojin").KuromojiToken} token
 * @returns {boolean}
 */


function isNumberToken(token) {
  return token.pos === "名詞" && token.pos_detail_1 === "数";
}

function _default(context) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var allowOnomatopee = options.allowOnomatopee !== undefined ? options.allowOnomatopee : DefaultOptions.allowOnomatopee;
  var allow = options.allow || DefaultOptions.allow;
  var {
    Syntax,
    RuleError,
    report,
    getSource
  } = context;
  return {
    [Syntax.Str](node) {
      var text = getSource(node);
      return (0, _kuromojin.tokenize)(text).then(tokens => {
        var prevToken = {};

        var reportIfMatch = (prevToken, nextToken) => {
          var prevWord = prevToken.surface_form;
          var currentWord = nextToken.surface_form;

          if (0 < allow.length && 0 < (0, _regexpStringMatcher.matchPatterns)(currentWord, allow).length) {
            return;
          }

          if (prevWord !== currentWord) {
            return;
          } // 漢数字は例外とする
          // 例) 値は"九九"です。
          // https://azu.github.io/morpheme-match/?text=%E5%80%A4%E3%81%AF%E4%B9%9D%E4%B9%9D%E3%81%A7%E3%81%99%E3%80%82


          if (isNumberToken(prevToken) && isNumberToken(nextToken)) {
            return;
          }

          if (allowOnomatopee && isOnomatopee(prevWord) && isOnomatopee(currentWord)) {
            return;
          }

          var index = Math.max(nextToken.word_position - 1, 0);
          report(node, new RuleError("\"".concat(currentWord, "\" \u304C\u9023\u7D9A\u3057\u30662\u56DE\u4F7F\u308F\u308C\u3066\u3044\u307E\u3059\u3002"), {
            index
          }));
        };

        tokens.forEach(token => {
          reportIfMatch(prevToken, token);
          prevToken = token;
        });
      });
    }

  };
}

;
//# sourceMappingURL=textlint-rule-ja-no-successive-word.js.map