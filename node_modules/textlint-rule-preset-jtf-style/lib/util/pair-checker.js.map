{"version":3,"file":"pair-checker.js","names":["Object","defineProperty","exports","value","checkPair","_assert","_interopRequireDefault","require","_textlintRuleHelper","e","__esModule","default","flat","array","concat","apply","context","left","right","assert","Syntax","RuleError","report","getSource","helper","RuleHelper","isInParagraph","currentStrInParagraph","findAllSymbolLocations","symbol","text","index","symbolLocations","length","indexOf","push","foundMissingPairNodes","matchParentheses","map","node","leftSymbolLocations","rightSymbolLocations","allSymbolLocations","sort","a","b","loc","isCompletedParentheses","lastUnmatchParences","item","shift","last","pop","Paragraph","isChildNode","BlockQuote","Str","missingPairList","forEach","message"],"sources":["../../src/util/pair-checker.js"],"sourcesContent":["// LICENSE : MIT\n\"use strict\";\n/**\n * 「と」といったペアがちゃんと閉じられているかをチェックします\n * @param {object} context\n * @param {string} left\n * @param {string} right\n * @returns {object}\n */\nimport assert from \"assert\";\nimport { RuleHelper } from \"textlint-rule-helper\";\nconst flat = (array) => {\n    return [].concat.apply([], array);\n};\nexport function checkPair(context, { left, right }) {\n    assert(left);\n    assert(right);\n    const { Syntax, RuleError, report, getSource } = context;\n    const helper = new RuleHelper(context);\n    let isInParagraph = false;\n    let currentStrInParagraph = [];\n    /**\n     * `Str` nodeの配列を受け取り、pairが見つからないnodeを返す\n     * @param {Object} currentStrInParagraph\n     * @returns {{node, index}[]}\n     */\n    const findAllSymbolLocations = (symbol, text) => {\n        let index = 0;\n        const symbolLocations = [];\n        while (index < text.length) {\n            index = text.indexOf(symbol, index);\n            if (index < 0) break;\n            symbolLocations.push({\n                index,\n                symbol\n            });\n            index += 1;\n        }\n        return symbolLocations;\n    };\n    const foundMissingPairNodes = (currentStrInParagraph) => {\n        const matchParentheses = flat(\n            currentStrInParagraph.map((node) => {\n                let text = getSource(node);\n                const leftSymbolLocations = findAllSymbolLocations(left, text);\n                const rightSymbolLocations = left !== right ? findAllSymbolLocations(right, text) : [];\n                const allSymbolLocations = [...leftSymbolLocations, ...rightSymbolLocations].sort(\n                    (a, b) => a.index - b.index\n                );\n                return allSymbolLocations.map((loc) => ({ ...loc, node }));\n            })\n        );\n        if (left === right) {\n            const isCompletedParentheses = matchParentheses.length % 2 == 0;\n            if (isCompletedParentheses) {\n                return [];\n            } else {\n                return [matchParentheses[matchParentheses.length - 1]];\n            }\n        } else {\n            const lastUnmatchParences = [];\n            while (matchParentheses.length > 0) {\n                const item = matchParentheses.shift();\n                if (item.symbol == left) {\n                    lastUnmatchParences.push(item);\n                } else {\n                    // right\n                    const last = lastUnmatchParences.pop();\n                    if (last) {\n                        if (last.symbol == right) {\n                            lastUnmatchParences.push(last);\n                            lastUnmatchParences.push(item);\n                        }\n                    } else {\n                        lastUnmatchParences.push(item);\n                    }\n                }\n            }\n            return lastUnmatchParences;\n        }\n    };\n    return {\n        [Syntax.Paragraph](node) {\n            if (helper.isChildNode(node, [Syntax.BlockQuote])) {\n                return;\n            }\n            currentStrInParagraph = [];\n            isInParagraph = true;\n        },\n        [Syntax.Str](node) {\n            if (!isInParagraph) {\n                return;\n            }\n            currentStrInParagraph.push(node);\n        },\n        [`${Syntax.Paragraph}:exit`]() {\n            const missingPairList = foundMissingPairNodes(currentStrInParagraph);\n            // 探索おわり\n            isInParagraph = false;\n            // 全ての対が見つかったなら配列は空になる\n            if (missingPairList.length === 0) {\n                return;\n            }\n            missingPairList.forEach(({ index, node, symbol }) => {\n                let message =\n                    symbol === left\n                        ? `${left}の対となる${right}が見つかりません。${left}${right}`\n                        : `${right}の対となる${left}が見つかりません。${left}${right}`;\n                report(node, new RuleError(message, { index }));\n            });\n        }\n    };\n}\n"],"mappings":"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","ignoreList":[]}