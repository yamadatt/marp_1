"use strict";

var _sentenceSplitter = require("sentence-splitter");
var _PairMaker = require("./parser/PairMaker.js");
var _SourceCode = require("./parser/SourceCode.js");
var _textlintRuleHelper = require("textlint-rule-helper");
// MIT Â© 2018 azu

const report = context => {
  const {
    Syntax,
    report,
    RuleError
  } = context;
  const ignoreNodeManager = new _textlintRuleHelper.IgnoreNodeManager();
  return {
    [Syntax.Paragraph](node) {
      const sentences = (0, _sentenceSplitter.splitAST)(node);
      ignoreNodeManager.ignoreChildrenByTypes(node, [Syntax.CodeBlock, Syntax.Code, Syntax.Link, Syntax.Strong, Syntax.Emphasis, Syntax.BlockQuote, Syntax.Comment]);
      sentences.children.filter(node => node.type === _sentenceSplitter.SentenceSplitterSyntax.Sentence).forEach(sentence => {
        const source = new _SourceCode.SourceCode(sentence.raw);
        const pairMaker = new _PairMaker.PairMaker();
        const sentenceIndex = sentence.range[0];
        while (source.canRead) {
          // If the character is in ignored range, skip it
          const characterIndex = sentenceIndex + source.index;
          // console.log(characterIndex, source.text[source.index], ignoreNodeManager.isIgnoredIndex(characterIndex));
          if (!ignoreNodeManager.isIgnoredIndex(characterIndex)) {
            pairMaker.mark(source);
          }
          source.peek();
        }
        // Report Error for each existing context keys
        source.contextLocations.forEach(contextLocation => {
          report(node, new RuleError(`Cannot find a pairing character for ${contextLocation.pairMark.start}.
                    
You should close this sentence with ${contextLocation.pairMark.end}.
This pair of marks is called ${contextLocation.pairMark.key}.`, {
            index: sentenceIndex - node.range[0] + contextLocation.index
          }));
        });
      });
    }
  };
};
module.exports = report;
//# sourceMappingURL=textlint-rule-no-unmatched-pair.js.map