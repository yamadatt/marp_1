import { TextlintKernelFilterRule, TextlintKernelOptions, TextlintKernelPlugin, TextlintKernelRule } from "../textlint-kernel-interface";
import { TextlintRuleDescriptors } from "./TextlintRuleDescriptors";
import { TextlintPluginDescriptors } from "./TextlintPluginDescriptors";
import { TextlintFilterRuleDescriptors } from "./TextlintFilterRuleDescriptors";
import { TextlintPluginDescriptor } from "./TextlintPluginDescriptor";
export interface TextlintKernelDescriptorArgs {
    configBaseDir?: string;
    rules: TextlintKernelRule[];
    filterRules: TextlintKernelFilterRule[];
    plugins: TextlintKernelPlugin[];
}
export declare class TextlintKernelDescriptor {
    private args;
    readonly rule: TextlintRuleDescriptors;
    readonly filterRule: TextlintFilterRuleDescriptors;
    readonly plugin: TextlintPluginDescriptors;
    readonly configBaseDir?: string;
    constructor(args: TextlintKernelDescriptorArgs);
    /**
     * Return available extensions of plugins
     */
    get availableExtensions(): string[];
    /**
     * Merge constructor args and partialArgs
     * It shallow merge partialArgs.
     * It means that overwrite own properties by partialArgs.
     */
    shallowMerge(partialArgs: Partial<TextlintKernelDescriptorArgs>): TextlintKernelDescriptor;
    /**
     * Concat descriptors
     * If A.concat(B), A is base, B is added
     * Note: withoutDuplicated pick A from [A, B] If A and B have same ruleId.
     * @param other
     */
    concat(other: TextlintKernelDescriptor): TextlintKernelDescriptor;
    /**
     * find PluginDescriptor with extension.
     * This is forward match.
     *
     * If following config of textlint, this method prefer to select MarkdownA for markdown.
     *
     * {
     *     "plugins": [MarkdownA, MarkdownB]
     * }
     */
    findPluginDescriptorWithExt(ext: string): TextlintPluginDescriptor | undefined;
    /**
     * Convert descriptor to TextlintKernelOptions
     */
    toKernelOptions(): Pick<TextlintKernelOptions, "configBaseDir" | "rules" | "filterRules" | "plugins">;
    toJSON(): {
        rule: {
            id: string;
            options: {
                [index: string]: any;
                severity?: import("@textlint/types").TextlintRuleSeverityLevel | undefined;
            };
        }[];
        filterRule: {
            id: string;
            options: import("@textlint/types").TextlintFilterRuleOptions;
        }[];
        plugin: {
            id: string;
            options: import("@textlint/types").TextlintPluginOptions;
        }[];
        configBaseDir: string | undefined;
    };
}
//# sourceMappingURL=TextlintKernelDescriptor.d.ts.map