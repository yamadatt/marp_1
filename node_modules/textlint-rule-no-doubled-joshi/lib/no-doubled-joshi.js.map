{"version":3,"file":"no-doubled-joshi.js","names":["Object","defineProperty","exports","value","default","_textlintRuleHelper","require","_sentenceSplitter","_kuromojin","_tokenUtils","_textlintUtilToString","asyncGeneratorStep","gen","resolve","reject","_next","_throw","key","arg","info","error","done","Promise","then","_asyncToGenerator","fn","self","args","arguments","apply","err","undefined","createSurfaceKeyMap","tokens","filter","is助詞Token","reduce","keyMap","token","tokenKey","createKeyFromKey","push","matchExceptionRule","joshiTokens","allTokens","pos_detail_1","surface_form","length","lastかIndex","indexOf","douToken","defaultOptions","min_interval","strict","allow","separatorCharacters","commaCharacters","toTextWithPrevWord","_ref","sentence","index","prevToken","DEFAULT_RESULT","concat","originalIndex","word_position","originalNode","children","find","node","range","type","raw","report","context","options","helper","RuleHelper","minInterval","Error","isStrict","Syntax","RuleError","locator","is読点Token","create読点Matcher","Paragraph","isChildNode","Link","Image","BlockQuote","Emphasis","isSentenceNode","SentenceSplitterSyntax","Sentence","txtParentNode","splitSentences","SeparatorParser","sentences","checkSentence","_ref2","sentenceSource","StringSource","replacer","_ref3","maskValue","Code","text","toString","tokenize","concatedJoshiTokens","concatJoishiTokens","countableJoshiTokens","is括弧Token","includes","joshiTokenSurfaceKeyMap","keys","forEach","joshiTokenSurfaceTokens","joshiName","restoreToSurfaceFromKey","prev","current","startPosition","otherPosition","differenceIndex","startWord","endWord","originalIndexFromIndex","padding","_x","all","map","_default"],"sources":["../src/no-doubled-joshi.ts"],"sourcesContent":["// LICENSE : MIT\n\"use strict\";\nimport { RuleHelper } from \"textlint-rule-helper\";\nimport {\n    SentenceSplitterSyntax,\n    SentenceSplitterTxtNode,\n    splitAST as splitSentences,\n    TxtSentenceNode\n} from \"sentence-splitter\";\nimport { KuromojiToken, tokenize } from \"kuromojin\";\nimport {\n    concatJoishiTokens,\n    createKeyFromKey,\n    create読点Matcher,\n    is助詞Token,\n    is括弧Token,\n    restoreToSurfaceFromKey\n} from \"./token-utils\";\nimport type { AnyTxtNode } from \"@textlint/ast-node-types\";\nimport type { TextlintRuleModule } from \"@textlint/types\";\nimport { StringSource } from \"textlint-util-to-string\";\nimport type { StringSourceTxtParentNodeLikeNode } from \"textlint-util-to-string/src/StringSource\";\n\n/**\n * Create token map object\n * {\n *  \"は:助詞.係助詞\": [token, token]\n * }\n * @param tokens\n * @returns {*}\n */\nfunction createSurfaceKeyMap(tokens: KuromojiToken[]): { [index: string]: KuromojiToken[] } {\n    // 助詞のみを対象とする\n    return tokens.filter(is助詞Token).reduce(\n        (keyMap, token) => {\n            // \"は:助詞.係助詞\" : [token]\n            const tokenKey = createKeyFromKey(token);\n            if (!keyMap[tokenKey]) {\n                keyMap[tokenKey] = [];\n            }\n            keyMap[tokenKey].push(token);\n            return keyMap;\n        },\n        {} as { [index: string]: KuromojiToken[] }\n    );\n}\n\nfunction matchExceptionRule(joshiTokens: KuromojiToken[], allTokens: KuromojiToken[]) {\n    const token = joshiTokens[0];\n    // \"の\" の重なりは例外\n    if (token.pos_detail_1 === \"連体化\") {\n        return true;\n    }\n    // \"を\" の重なりは例外\n    if (token.pos_detail_1 === \"格助詞\" && token.surface_form === \"を\") {\n        return true;\n    }\n    // 接続助詞 \"て\" の重なりは例外\n    if (token.pos_detail_1 === \"接続助詞\" && token.surface_form === \"て\") {\n        return true;\n    }\n    // 並立助詞は例外\n    // 登ったり降りたり\n    if (\n        joshiTokens.length === 2 &&\n        joshiTokens[0].pos_detail_1 === \"並立助詞\" &&\n        joshiTokens[1].pos_detail_1 === \"並立助詞\"\n    ) {\n        return true;\n    }\n    // 〜か〜か のパターン\n    // 〜かどうか は例外 として許容する\n    if (joshiTokens.length === 2 && joshiTokens[0].surface_form === \"か\" && joshiTokens[1].surface_form === \"か\") {\n        // 〜|か|どう|か|\n        const lastかIndex = allTokens.indexOf(joshiTokens[1]);\n        const douToken = allTokens[lastかIndex - 1];\n        if (douToken && douToken.surface_form === \"どう\") {\n            return true;\n        }\n    }\n    return false;\n}\n\n/*\n default options\n */\nconst defaultOptions = {\n    min_interval: 1,\n    strict: false,\n    allow: [],\n    separatorCharacters: [\n        \".\", // period\n        \"．\", // (ja) zenkaku-period\n        \"。\", // (ja) 句点\n        \"?\", // question mark\n        \"!\", //  exclamation mark\n        \"？\", // (ja) zenkaku question mark\n        \"！\" // (ja) zenkaku exclamation mark\n    ],\n    commaCharacters: [\n        \"、\",\n        \"，\" // 全角カンマ\n    ]\n};\n\nexport interface Options {\n    /**\n     * 助詞の最低間隔値\n     * 指定した間隔値以下で同じ助詞が出現した場合エラーが出力されます\n     * デフォルトは1なので、同じ助詞が連続した場合にエラーとなります。\n     */\n    min_interval?: number;\n    /**\n     * デフォルトの例外パターンもエラーにするかどうか\n     * デフォルト: false\n     */\n    strict?: boolean;\n    /**\n     * 複数回の出現を許す助詞の配列\n     * 例): [\"も\", \"や\"]\n     */\n    allow?: string[];\n    /**\n     * 文の区切りとなる文字(句点)の配列\n     */\n    separatorCharacters?: string[];\n    /**\n     * 読点となる文字の配列\n     */\n    commaCharacters?: string[];\n}\n\n/**\n * \"~~~~~~{助詞}\" から {Token}\"{助詞}\" という形になるように、前の単語を含めた助詞の文字列を取得する\n *\n * 前のNodeがStrの場合は、一つ前のTokenを取得する\n * {Str}{助詞} -> {Token}\"{助詞}\"\n *\n * それ以外のNodeの場合は、そのNodeの文字列を取得する\n * {Code}{助詞} -> {Code}\"{助詞}\"\n * {Strong}{助詞} -> {Strong}\"{助詞}\"\n *\n * @param token\n * @param tokens\n * @param sentence\n */\nconst toTextWithPrevWord = (\n    token: KuromojiToken,\n    {\n        tokens,\n        sentence\n    }: {\n        tokens: KuromojiToken[];\n        sentence: TxtSentenceNode;\n    }\n) => {\n    const index = tokens.indexOf(token);\n    const prevToken = tokens[index - 1];\n    // 前のTokenがない場合は、Tokenのsurface_formを返す\n    const DEFAULT_RESULT = `\"${token.surface_form}\"`;\n    if (!prevToken) {\n        return DEFAULT_RESULT;\n    }\n    const originalIndex = prevToken.word_position - 1;\n    if (originalIndex === undefined) {\n        return DEFAULT_RESULT;\n    }\n    // Tokenの位置に該当するNodeを取得する\n    const originalNode = sentence.children.find((node) => {\n        return node.range[0] <= originalIndex && originalIndex < node.range[1];\n    });\n    if (originalNode === undefined) {\n        return DEFAULT_RESULT;\n    }\n    if (originalNode.type === \"Str\") {\n        return `${prevToken.surface_form}\"${token.surface_form}\"`;\n    }\n    return `${originalNode.raw}\"${token.surface_form}\"`;\n};\n/*\n 1. Paragraph Node -> text\n 2. text -> sentences\n 3. tokenize sentence\n 4. report error if found word that match the rule.\n */\nconst report: TextlintRuleModule<Options> = function (context, options = {}) {\n    const helper = new RuleHelper(context);\n    // 最低間隔値\n    const minInterval = options.min_interval !== undefined ? options.min_interval : defaultOptions.min_interval;\n    if (minInterval <= 0) {\n        throw new Error(\"options.min_intervalは1以上の数値を指定してください\");\n    }\n    const isStrict = options.strict || defaultOptions.strict;\n    const allow = options.allow || defaultOptions.allow;\n    const separatorCharacters = options.separatorCharacters || defaultOptions.separatorCharacters;\n    const commaCharacters = options.commaCharacters || defaultOptions.commaCharacters;\n    const { Syntax, report, RuleError, locator } = context;\n    const is読点Token = create読点Matcher(commaCharacters);\n    return {\n        [Syntax.Paragraph](node) {\n            if (helper.isChildNode(node, [Syntax.Link, Syntax.Image, Syntax.BlockQuote, Syntax.Emphasis])) {\n                return;\n            }\n            const isSentenceNode = (node: SentenceSplitterTxtNode | AnyTxtNode): node is TxtSentenceNode => {\n                return node.type === SentenceSplitterSyntax.Sentence;\n            };\n            const txtParentNode = splitSentences(node, {\n                SeparatorParser: {\n                    separatorCharacters\n                }\n            });\n            const sentences = txtParentNode.children.filter(isSentenceNode);\n            const checkSentence = async (sentence: TxtSentenceNode) => {\n                // コードの中身は無視するため、無意味な文字列に置き換える\n                const sentenceSource = new StringSource(sentence as StringSourceTxtParentNodeLikeNode, {\n                    replacer({ node, maskValue }) {\n                        /*\n                         * `obj.method` のCode Nodeのように、区切り文字として意味をもつノードがある場合に、\n                         * このルールでは単純に無視したいので、同じ文字数で意味のない文字列に置き換える\n                         */\n                        if (node.type === Syntax.Code) {\n                            return maskValue(\"ー\");\n                        }\n                        return;\n                    }\n                });\n                const text = sentenceSource.toString();\n                const tokens = await tokenize(text);\n                // 助詞 + 助詞は 一つの助詞として扱う\n                // https://github.com/textlint-ja/textlint-rule-no-doubled-joshi/issues/15\n                // 連語(助詞)の対応\n                // http://www.weblio.jp/parts-of-speech/%E9%80%A3%E8%AA%9E(%E5%8A%A9%E8%A9%9E)_1\n                const concatedJoshiTokens = concatJoishiTokens(tokens);\n                const countableJoshiTokens = concatedJoshiTokens.filter((token) => {\n                    if (isStrict) {\n                        return is助詞Token(token);\n                    }\n                    // デフォルトでは、\"、\"などを間隔値の距離としてカウントする\n                    // \"(\"や\")\"などもトークンとしてカウントする\n                    // xxxx（xxx) xxx でカッコの中と外に距離を一つ増やす目的\n                    // https://github.com/textlint-ja/textlint-rule-no-doubled-joshi/issues/31\n                    if (is括弧Token(token)) {\n                        return true;\n                    }\n                    // sentence-splitterでセンテンスに区切った場合、 \"Xは「カッコ書きの中の文」と言った。\" というように、「」の中の文は区切られない\n                    // そのため、トークナイズしたトークンで区切り文字となる文字(。や.）があった場合には、カウントを増やす\n                    // デフォルトではmin_interval:1 なので、「今日は早朝から出発したが、定刻には間に合わなかった。定刻には間に合わなかったが、無事会場に到着した」のようなものがエラーではなくなる\n                    // https://github.com/textlint-ja/textlint-rule-no-doubled-joshi/issues/40\n                    if (separatorCharacters.includes(token.surface_form)) {\n                        return true;\n                    }\n                    // \"、\" があると助詞同士の距離が開くようにすることで、並列的な\"、\"の使い方を許容する目的\n                    // https://github.com/azu/textlint-rule-no-doubled-joshi/issues/2\n                    if (is読点Token(token)) {\n                        return true;\n                    }\n                    return is助詞Token(token);\n                });\n                const joshiTokenSurfaceKeyMap = createSurfaceKeyMap(countableJoshiTokens);\n                /*\n                    # Data Structure\n\n                    joshiTokens = [tokenA, tokenB, tokenC, tokenD, tokenE, tokenF]\n                    joshiTokenSurfaceKeyMap = {\n                        \"は:助詞.係助詞\": [tokenA, tokenC, tokenE],\n                        \"で:助詞.係助詞\": [tokenB, tokenD, tokenF]\n                    }\n                    */\n                Object.keys(joshiTokenSurfaceKeyMap).forEach((key) => {\n                    const joshiTokenSurfaceTokens: KuromojiToken[] = joshiTokenSurfaceKeyMap[key];\n                    const joshiName = restoreToSurfaceFromKey(key);\n                    // check allow\n                    if (allow.includes(joshiName)) {\n                        return;\n                    }\n                    // strict mode ではない時例外を除去する\n                    if (!isStrict) {\n                        if (matchExceptionRule(joshiTokenSurfaceTokens, tokens)) {\n                            return;\n                        }\n                    }\n                    if (joshiTokenSurfaceTokens.length <= 1) {\n                        return; // no duplicated token\n                    }\n                    // if found differenceIndex less than\n                    // tokes are sorted ascending order\n                    joshiTokenSurfaceTokens.reduce((prev, current) => {\n                        const startPosition = countableJoshiTokens.indexOf(prev);\n                        const otherPosition = countableJoshiTokens.indexOf(current);\n                        // 助詞token同士の距離が設定値以下ならエラーを報告する\n                        const differenceIndex = otherPosition - startPosition;\n                        if (differenceIndex <= minInterval) {\n                            // 連続する助詞を集める\n                            const startWord = toTextWithPrevWord(prev, {\n                                tokens: tokens,\n                                sentence: sentence\n                            });\n                            const endWord = toTextWithPrevWord(current, {\n                                tokens: tokens,\n                                sentence: sentence\n                            });\n                            // padding positionを計算する\n                            const originalIndex = sentenceSource.originalIndexFromIndex(current.word_position - 1);\n                            // originalIndexがない場合は基本的にはないが、ない場合は無視する\n                            if (originalIndex === undefined) {\n                                return current;\n                            }\n                            report(\n                                // @ts-expect-error: SentenceNodeは独自であるため\n                                sentence,\n                                new RuleError(\n                                    `一文に二回以上利用されている助詞 \"${joshiName}\" がみつかりました。\n\n次の助詞が連続しているため、文を読みにくくしています。\n\n- ${startWord}\n- ${endWord}\n\n同じ助詞を連続して利用しない、文の中で順番を入れ替える、文を分割するなどを検討してください。\n`,\n                                    {\n                                        padding: locator.range([\n                                            originalIndex,\n                                            originalIndex + current.surface_form.length\n                                        ])\n                                    }\n                                )\n                            );\n                        }\n                        return current;\n                    });\n                });\n            };\n            return Promise.all(sentences.map(checkSentence));\n        }\n    };\n};\nexport default report;\n"],"mappings":"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"}