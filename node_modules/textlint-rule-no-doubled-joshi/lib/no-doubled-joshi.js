// LICENSE : MIT
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _textlintRuleHelper = require("textlint-rule-helper");
var _sentenceSplitter = require("sentence-splitter");
var _kuromojin = require("kuromojin");
var _tokenUtils = require("./token-utils");
var _textlintUtilToString = require("textlint-util-to-string");
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
/**
 * Create token map object
 * {
 *  "は:助詞.係助詞": [token, token]
 * }
 * @param tokens
 * @returns {*}
 */
function createSurfaceKeyMap(tokens) {
  // 助詞のみを対象とする
  return tokens.filter(_tokenUtils.is助詞Token).reduce((keyMap, token) => {
    // "は:助詞.係助詞" : [token]
    var tokenKey = (0, _tokenUtils.createKeyFromKey)(token);
    if (!keyMap[tokenKey]) {
      keyMap[tokenKey] = [];
    }
    keyMap[tokenKey].push(token);
    return keyMap;
  }, {});
}
function matchExceptionRule(joshiTokens, allTokens) {
  var token = joshiTokens[0];
  // "の" の重なりは例外
  if (token.pos_detail_1 === "連体化") {
    return true;
  }
  // "を" の重なりは例外
  if (token.pos_detail_1 === "格助詞" && token.surface_form === "を") {
    return true;
  }
  // 接続助詞 "て" の重なりは例外
  if (token.pos_detail_1 === "接続助詞" && token.surface_form === "て") {
    return true;
  }
  // 並立助詞は例外
  // 登ったり降りたり
  if (joshiTokens.length === 2 && joshiTokens[0].pos_detail_1 === "並立助詞" && joshiTokens[1].pos_detail_1 === "並立助詞") {
    return true;
  }
  // 〜か〜か のパターン
  // 〜かどうか は例外 として許容する
  if (joshiTokens.length === 2 && joshiTokens[0].surface_form === "か" && joshiTokens[1].surface_form === "か") {
    // 〜|か|どう|か|
    var lastかIndex = allTokens.indexOf(joshiTokens[1]);
    var douToken = allTokens[lastかIndex - 1];
    if (douToken && douToken.surface_form === "どう") {
      return true;
    }
  }
  return false;
}

/*
 default options
 */
var defaultOptions = {
  min_interval: 1,
  strict: false,
  allow: [],
  separatorCharacters: [".",
  // period
  "．",
  // (ja) zenkaku-period
  "。",
  // (ja) 句点
  "?",
  // question mark
  "!",
  //  exclamation mark
  "？",
  // (ja) zenkaku question mark
  "！" // (ja) zenkaku exclamation mark
  ],

  commaCharacters: ["、", "，" // 全角カンマ
  ]
};

/**
 * "~~~~~~{助詞}" から {Token}"{助詞}" という形になるように、前の単語を含めた助詞の文字列を取得する
 *
 * 前のNodeがStrの場合は、一つ前のTokenを取得する
 * {Str}{助詞} -> {Token}"{助詞}"
 *
 * それ以外のNodeの場合は、そのNodeの文字列を取得する
 * {Code}{助詞} -> {Code}"{助詞}"
 * {Strong}{助詞} -> {Strong}"{助詞}"
 *
 * @param token
 * @param tokens
 * @param sentence
 */
var toTextWithPrevWord = (token, _ref) => {
  var {
    tokens,
    sentence
  } = _ref;
  var index = tokens.indexOf(token);
  var prevToken = tokens[index - 1];
  // 前のTokenがない場合は、Tokenのsurface_formを返す
  var DEFAULT_RESULT = "\"".concat(token.surface_form, "\"");
  if (!prevToken) {
    return DEFAULT_RESULT;
  }
  var originalIndex = prevToken.word_position - 1;
  if (originalIndex === undefined) {
    return DEFAULT_RESULT;
  }
  // Tokenの位置に該当するNodeを取得する
  var originalNode = sentence.children.find(node => {
    return node.range[0] <= originalIndex && originalIndex < node.range[1];
  });
  if (originalNode === undefined) {
    return DEFAULT_RESULT;
  }
  if (originalNode.type === "Str") {
    return "".concat(prevToken.surface_form, "\"").concat(token.surface_form, "\"");
  }
  return "".concat(originalNode.raw, "\"").concat(token.surface_form, "\"");
};
/*
 1. Paragraph Node -> text
 2. text -> sentences
 3. tokenize sentence
 4. report error if found word that match the rule.
 */
var report = function report(context) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var helper = new _textlintRuleHelper.RuleHelper(context);
  // 最低間隔値
  var minInterval = options.min_interval !== undefined ? options.min_interval : defaultOptions.min_interval;
  if (minInterval <= 0) {
    throw new Error("options.min_intervalは1以上の数値を指定してください");
  }
  var isStrict = options.strict || defaultOptions.strict;
  var allow = options.allow || defaultOptions.allow;
  var separatorCharacters = options.separatorCharacters || defaultOptions.separatorCharacters;
  var commaCharacters = options.commaCharacters || defaultOptions.commaCharacters;
  var {
    Syntax,
    report,
    RuleError,
    locator
  } = context;
  var is読点Token = (0, _tokenUtils.create読点Matcher)(commaCharacters);
  return {
    [Syntax.Paragraph](node) {
      if (helper.isChildNode(node, [Syntax.Link, Syntax.Image, Syntax.BlockQuote, Syntax.Emphasis])) {
        return;
      }
      var isSentenceNode = node => {
        return node.type === _sentenceSplitter.SentenceSplitterSyntax.Sentence;
      };
      var txtParentNode = (0, _sentenceSplitter.splitAST)(node, {
        SeparatorParser: {
          separatorCharacters
        }
      });
      var sentences = txtParentNode.children.filter(isSentenceNode);
      var checkSentence = /*#__PURE__*/function () {
        var _ref2 = _asyncToGenerator(function* (sentence) {
          // コードの中身は無視するため、無意味な文字列に置き換える
          var sentenceSource = new _textlintUtilToString.StringSource(sentence, {
            replacer(_ref3) {
              var {
                node,
                maskValue
              } = _ref3;
              /*
               * `obj.method` のCode Nodeのように、区切り文字として意味をもつノードがある場合に、
               * このルールでは単純に無視したいので、同じ文字数で意味のない文字列に置き換える
               */
              if (node.type === Syntax.Code) {
                return maskValue("ー");
              }
              return;
            }
          });
          var text = sentenceSource.toString();
          var tokens = yield (0, _kuromojin.tokenize)(text);
          // 助詞 + 助詞は 一つの助詞として扱う
          // https://github.com/textlint-ja/textlint-rule-no-doubled-joshi/issues/15
          // 連語(助詞)の対応
          // http://www.weblio.jp/parts-of-speech/%E9%80%A3%E8%AA%9E(%E5%8A%A9%E8%A9%9E)_1
          var concatedJoshiTokens = (0, _tokenUtils.concatJoishiTokens)(tokens);
          var countableJoshiTokens = concatedJoshiTokens.filter(token => {
            if (isStrict) {
              return (0, _tokenUtils.is助詞Token)(token);
            }
            // デフォルトでは、"、"などを間隔値の距離としてカウントする
            // "("や")"などもトークンとしてカウントする
            // xxxx（xxx) xxx でカッコの中と外に距離を一つ増やす目的
            // https://github.com/textlint-ja/textlint-rule-no-doubled-joshi/issues/31
            if ((0, _tokenUtils.is括弧Token)(token)) {
              return true;
            }
            // sentence-splitterでセンテンスに区切った場合、 "Xは「カッコ書きの中の文」と言った。" というように、「」の中の文は区切られない
            // そのため、トークナイズしたトークンで区切り文字となる文字(。や.）があった場合には、カウントを増やす
            // デフォルトではmin_interval:1 なので、「今日は早朝から出発したが、定刻には間に合わなかった。定刻には間に合わなかったが、無事会場に到着した」のようなものがエラーではなくなる
            // https://github.com/textlint-ja/textlint-rule-no-doubled-joshi/issues/40
            if (separatorCharacters.includes(token.surface_form)) {
              return true;
            }
            // "、" があると助詞同士の距離が開くようにすることで、並列的な"、"の使い方を許容する目的
            // https://github.com/azu/textlint-rule-no-doubled-joshi/issues/2
            if (is読点Token(token)) {
              return true;
            }
            return (0, _tokenUtils.is助詞Token)(token);
          });
          var joshiTokenSurfaceKeyMap = createSurfaceKeyMap(countableJoshiTokens);
          /*
              # Data Structure
               joshiTokens = [tokenA, tokenB, tokenC, tokenD, tokenE, tokenF]
              joshiTokenSurfaceKeyMap = {
                  "は:助詞.係助詞": [tokenA, tokenC, tokenE],
                  "で:助詞.係助詞": [tokenB, tokenD, tokenF]
              }
              */
          Object.keys(joshiTokenSurfaceKeyMap).forEach(key => {
            var joshiTokenSurfaceTokens = joshiTokenSurfaceKeyMap[key];
            var joshiName = (0, _tokenUtils.restoreToSurfaceFromKey)(key);
            // check allow
            if (allow.includes(joshiName)) {
              return;
            }
            // strict mode ではない時例外を除去する
            if (!isStrict) {
              if (matchExceptionRule(joshiTokenSurfaceTokens, tokens)) {
                return;
              }
            }
            if (joshiTokenSurfaceTokens.length <= 1) {
              return; // no duplicated token
            }
            // if found differenceIndex less than
            // tokes are sorted ascending order
            joshiTokenSurfaceTokens.reduce((prev, current) => {
              var startPosition = countableJoshiTokens.indexOf(prev);
              var otherPosition = countableJoshiTokens.indexOf(current);
              // 助詞token同士の距離が設定値以下ならエラーを報告する
              var differenceIndex = otherPosition - startPosition;
              if (differenceIndex <= minInterval) {
                // 連続する助詞を集める
                var startWord = toTextWithPrevWord(prev, {
                  tokens: tokens,
                  sentence: sentence
                });
                var endWord = toTextWithPrevWord(current, {
                  tokens: tokens,
                  sentence: sentence
                });
                // padding positionを計算する
                var originalIndex = sentenceSource.originalIndexFromIndex(current.word_position - 1);
                // originalIndexがない場合は基本的にはないが、ない場合は無視する
                if (originalIndex === undefined) {
                  return current;
                }
                report(
                // @ts-expect-error: SentenceNodeは独自であるため
                sentence, new RuleError("\u4E00\u6587\u306B\u4E8C\u56DE\u4EE5\u4E0A\u5229\u7528\u3055\u308C\u3066\u3044\u308B\u52A9\u8A5E \"".concat(joshiName, "\" \u304C\u307F\u3064\u304B\u308A\u307E\u3057\u305F\u3002\n\n\u6B21\u306E\u52A9\u8A5E\u304C\u9023\u7D9A\u3057\u3066\u3044\u308B\u305F\u3081\u3001\u6587\u3092\u8AAD\u307F\u306B\u304F\u304F\u3057\u3066\u3044\u307E\u3059\u3002\n\n- ").concat(startWord, "\n- ").concat(endWord, "\n\n\u540C\u3058\u52A9\u8A5E\u3092\u9023\u7D9A\u3057\u3066\u5229\u7528\u3057\u306A\u3044\u3001\u6587\u306E\u4E2D\u3067\u9806\u756A\u3092\u5165\u308C\u66FF\u3048\u308B\u3001\u6587\u3092\u5206\u5272\u3059\u308B\u306A\u3069\u3092\u691C\u8A0E\u3057\u3066\u304F\u3060\u3055\u3044\u3002\n"), {
                  padding: locator.range([originalIndex, originalIndex + current.surface_form.length])
                }));
              }
              return current;
            });
          });
        });
        return function checkSentence(_x) {
          return _ref2.apply(this, arguments);
        };
      }();
      return Promise.all(sentences.map(checkSentence));
    }
  };
};
var _default = exports.default = report;
//# sourceMappingURL=no-doubled-joshi.js.map