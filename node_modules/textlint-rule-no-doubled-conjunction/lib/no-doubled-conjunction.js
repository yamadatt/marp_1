// LICENSE : MIT
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
var _textlintRuleHelper = require("textlint-rule-helper");
var _kuromojin = require("kuromojin");
var _sentenceSplitter = require("sentence-splitter");
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
/*
    1. Paragraph Node -> text
    2. text -> sentences
    3. tokenize sentence
    4. report error if found word that match the rule.

    TODO: need abstraction
 */
/**
 * @param {import("@textlint/types").TextlintRuleContext}context
 * @param {*} options
 * @returns {import("@textlint/types").TextlintRuleReporter}
 */
function _default(context) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var helper = new _textlintRuleHelper.RuleHelper(context);
  var {
    Syntax,
    report,
    RuleError,
    locator
  } = context;
  return {
    [Syntax.Paragraph](node) {
      return _asyncToGenerator(function* () {
        if (helper.isChildNode(node, [Syntax.Link, Syntax.Image, Syntax.BlockQuote, Syntax.Emphasis])) {
          return;
        }
        var isSentenceNode = node => node.type === _sentenceSplitter.SentenceSplitterSyntax.Sentence;
        var sentences = (0, _sentenceSplitter.splitAST)(node, {
          SeparatorParser: {
            separatorCharacters: [".",
            // period
            "．",
            // (ja) zenkaku-period
            "。",
            // (ja) 句点
            "?",
            // question mark
            "!",
            //  exclamation mark
            "？",
            // (ja) zenkaku question mark
            "！" // (ja) zenkaku exclamation mark
            ]
          }
        }).children.filter(isSentenceNode);
        // if not have a sentence, early return
        // It is for avoiding error of emptyArray.reduce().
        if (sentences.length === 0) {
          return;
        }
        var selectConjenction = /*#__PURE__*/function () {
          var _ref = _asyncToGenerator(function* (sentence) {
            var tokens = yield (0, _kuromojin.tokenize)(sentence.raw);
            var conjunctionTokens = tokens.filter((token, index) => {
              var prevToken = tokens[index - 1];
              // スペースが切れ目として認識されてしまう問題を回避
              // https://github.com/textlint-ja/textlint-rule-no-doubled-conjunction/issues/14
              if (prevToken && prevToken.pos_detail_1 === "空白" && token.pos === "接続詞") {
                return false;
              }
              return token.pos === "接続詞";
            });
            return [sentence, conjunctionTokens];
          });
          return function selectConjenction(_x) {
            return _ref.apply(this, arguments);
          };
        }();
        var prev_token = null;
        var result = yield Promise.all(sentences.map(selectConjenction));
        result.reduce((prev, current) => {
          var [sentence, current_tokens] = current;
          var [prev_sentence, prev_tokens] = prev;
          var token = prev_token;
          if (prev_tokens && prev_tokens.length > 0) {
            token = prev_tokens[0];
          }
          if (current_tokens.length > 0) {
            if (token && current_tokens[0].surface_form === token.surface_form) {
              var conjunctionSurface = token.surface_form;
              // padding position
              report(sentence, new RuleError("\u540C\u3058\u63A5\u7D9A\u8A5E\uFF08".concat(conjunctionSurface, "\uFF09\u304C\u9023\u7D9A\u3057\u3066\u4F7F\u308F\u308C\u3066\u3044\u307E\u3059\u3002"), {
                padding: locator.range([token.word_position - 1, token.word_position + conjunctionSurface.length - 1])
              }));
            }
          }
          prev_token = token;
          return current;
        });
      })();
    }
  };
}
;
//# sourceMappingURL=no-doubled-conjunction.js.map