"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.matchPatterns = exports.createRegExp = void 0;
var lodash_uniq_1 = __importDefault(require("lodash.uniq"));
var lodash_uniqwith_1 = __importDefault(require("lodash.uniqwith"));
var lodash_sortby_1 = __importDefault(require("lodash.sortby"));
var escape_string_regexp_1 = __importDefault(require("escape-string-regexp"));
var regexp_parse_1 = require("./regexp-parse");
var DEFAULT_FLAGS = "ug";
var defaultFlags = function (flagsString) {
    if (flagsString.length === 0) {
        return DEFAULT_FLAGS;
    }
    return (0, lodash_uniq_1.default)((flagsString + DEFAULT_FLAGS).split("")).join("");
};
var createRegExp = function (patternString, defaultFlag) {
    if (defaultFlag === void 0) { defaultFlag = DEFAULT_FLAGS; }
    if (patternString.length === 0) {
        throw new Error("Empty string can not handled");
    }
    if ((0, regexp_parse_1.isRegExpString)(patternString)) {
        var regExpStructure = (0, regexp_parse_1.parseRegExpString)(patternString);
        if (regExpStructure) {
            return new RegExp(regExpStructure.source, defaultFlags(regExpStructure.flagString));
        }
        throw new Error("\"".concat(patternString, "\" can not parse as RegExp."));
    }
    else {
        return new RegExp((0, escape_string_regexp_1.default)(patternString), defaultFlag);
    }
};
exports.createRegExp = createRegExp;
var isEqualMatchPatternResult = function (a, b) {
    return a.startIndex === b.startIndex && a.endIndex === b.endIndex && a.match === b.match;
};
/**
 * Match regExpLikeStrings and return matchPatternResults
 * @param text target text
 * @param regExpLikeStrings an array of pattern string
 */
var matchPatterns = function (text, regExpLikeStrings) {
    var matchPatternResults = [];
    regExpLikeStrings
        .map(function (patternString) {
        return (0, exports.createRegExp)(patternString);
    })
        .forEach(function (regExp) {
        var results = text.matchAll(regExp);
        Array.from(results).forEach(function (result) {
            if (result.index === undefined) {
                return;
            }
            var match = result[0];
            var index = result.index;
            matchPatternResults.push({
                match: match,
                captures: result.slice(1),
                startIndex: index,
                endIndex: index + match.length
            });
        });
    });
    var uniqResults = (0, lodash_uniqwith_1.default)(matchPatternResults, isEqualMatchPatternResult);
    return (0, lodash_sortby_1.default)(uniqResults, ["startIndex", "endIndex"]);
};
exports.matchPatterns = matchPatterns;
//# sourceMappingURL=regexp-string-matcher.js.map