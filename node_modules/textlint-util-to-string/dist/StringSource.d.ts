import type { TxtNode, TxtNodeLocation, TxtNodeRange, TxtParagraphNode } from "@textlint/ast-node-types";
import { SourcePosition } from "structured-source";
import { emptyValue, maskValue, StringSourceReplacerCommand } from "./replacer";
import { UnistNode } from "./UnistNode";
export type StringSourceOptions = {
    replacer?: ({ node, parent }: {
        node: TxtNode | UnistNode;
        parent?: StringSourceTxtParentNodeLikeNode;
        maskValue: typeof maskValue;
        emptyValue: typeof emptyValue;
    }) => StringSourceReplacerCommand | undefined;
};
/**
 * TxtTxtNode-like definition
 * It is intentionally loose definition to accept sentences-splitter's node and unist node.
 */
export type StringSourceTxtTxtNode = {
    type: string;
    raw: string;
    range: TxtNodeRange;
    loc: TxtNodeLocation;
    value?: string | null | undefined;
};
/**
 * TxtParentNode-like definition
 * It is intentionally loose definition to accept sentences-splitter's node and unist node.
 */
export type StringSourceTxtParentNodeLikeNode = {
    type: string;
    raw: string;
    range: TxtNodeRange;
    loc: TxtNodeLocation;
    children: (StringSourceTxtTxtNode | StringSourceTxtParentNodeLikeNode)[];
};
export declare class StringSource {
    private rootNode;
    private generatedString;
    private originalSource;
    private generatedSource;
    private tokenMaps;
    constructor(node: StringSourceTxtParentNodeLikeNode, options?: StringSourceOptions);
    toString(): string;
    /**
     * @deprecated use originalIndexFromIndex instead of
     * @param targetIndex
     */
    originalIndexFor(targetIndex: number): number | undefined;
    /**
     * @deprecated use originalPositionFromPosition instead of
     * @param generatedPosition
     * @param {boolean}  isEnd - is the position end of the node?

     * @returns {Object}
     */
    originalPositionFor(generatedPosition: SourcePosition, isEnd?: boolean): SourcePosition | undefined;
    /**
     * get original index from generated index value
     * @param {number} generatedIndex - position is a index value.
     * @param {boolean}  isEnd - is the position end of the node?
     * @returns {number|undefined} original
     */
    originalIndexFromIndex(generatedIndex: number, isEnd?: boolean): number | undefined;
    /**
     * get original position from generated position
     * @param {object} position
     * @param {boolean}  isEnd - is the position end of the node?
     * @returns {object} original position
     */
    originalPositionFromPosition(position: SourcePosition, isEnd?: boolean): SourcePosition | undefined;
    /**
     * get original index from generated position
     * @param {object} generatedPosition
     * @param {boolean}  isEnd - is the position end of the node?
     * @returns {number} original index
     */
    originalIndexFromPosition(generatedPosition: SourcePosition, isEnd?: boolean): number | undefined;
    /**
     * get original position from generated index
     * @param {number} generatedIndex
     * @param {boolean} isEnd - is the position end of the node?
     * @return {object} original position
     */
    originalPositionFromIndex(generatedIndex: number, isEnd?: boolean): SourcePosition | undefined;
    isParagraphNode(node: TxtNode | StringSourceTxtParentNodeLikeNode): node is TxtParagraphNode;
    isStringNode(node: TxtNode | UnistNode): boolean;
    /**
     *
     * @param node
     * @returns {string|undefined}
     * @private
     */
    private _getValue;
    private _nodeRangeAsRelative;
    private _valueOf;
    private _addTokenMap;
    /**
     * Compute text content of a node.  If the node itself
     * does not expose plain-text fields, `toString` will
     * recursively map
     *
     * @param {Node} node - Node to transform to a string.
     * @param {Node} [parent] - Parent Node of the `node`.
     * @param options
     */
    private _stringify;
}
