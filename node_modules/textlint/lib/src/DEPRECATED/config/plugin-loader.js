"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.loadAvailableExtensions = exports.getPluginConfig = exports.getPluginNames = void 0;
const module_interop_1 = require("@textlint/module-interop");
const debug_1 = __importDefault(require("debug"));
const assert_1 = __importDefault(require("assert"));
const debug = (0, debug_1.default)("textlint:plugin-loader");
/**
 * get plugin names from `configFileRaw` object
 * @param configFileRaw
 * @returns {Array}
 */
function getPluginNames(configFileRaw) {
    const plugins = configFileRaw.plugins;
    if (!plugins) {
        return [];
    }
    if (Array.isArray(plugins)) {
        return plugins;
    }
    return Object.keys(plugins);
}
exports.getPluginNames = getPluginNames;
/**
 * get pluginConfig object from `configFileRaw` that is loaded .textlintrc
 * @param {Object} configFileRaw
 * @returns {Object}
 * @example
 * ```js
 * "plugins": {
 *   "pluginA": {},
 *   "pluginB": {}
 * }
 * ```
 *
 * to
 *
 * ```js
 * {
 *   "pluginA": {},
 *   "pluginB": {}
 * }
 * ```
 *
 *
 *
 * ```js
 * "plugins": ["pluginA", "pluginB"]
 * ```
 *
 * to
 *
 * ```
 * // `true` means turn on
 * {
 *   "pluginA": true,
 *   "pluginB": true
 * }
 * ```
 */
function getPluginConfig(configFileRaw) {
    const plugins = configFileRaw.plugins;
    if (!plugins) {
        return {};
    }
    if (Array.isArray(plugins)) {
        if (plugins.length === 0) {
            return {};
        }
        // { "pluginA": true, "pluginB": true }
        return plugins.reduce((results, pluginName) => {
            results[pluginName] = true;
            return results;
        }, {});
    }
    return plugins;
}
exports.getPluginConfig = getPluginConfig;
function loadAvailableExtensions(pluginNames = [], moduleResolver) {
    const availableExtensions = [];
    pluginNames.forEach((pluginName) => {
        const pkgPath = moduleResolver.resolvePluginPackageName(pluginName);
        const plugin = (0, module_interop_1.moduleInterop)(require(pkgPath));
        if (!plugin.hasOwnProperty("Processor")) {
            return;
        }
        const Processor = plugin.Processor;
        debug(`${pluginName} has Processor`);
        assert_1.default.ok(typeof Processor.availableExtensions === "function", "Processor.availableExtensions() should be implemented");
        availableExtensions.push(...Processor.availableExtensions());
    });
    return availableExtensions;
}
exports.loadAvailableExtensions = loadAvailableExtensions;
//# sourceMappingURL=plugin-loader.js.map